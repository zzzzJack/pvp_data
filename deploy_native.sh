#!/bin/bash

# ============================================
# PVP数据看板系统 - 原生环境一键部署脚本 (CentOS)
# ============================================

set -e  # 遇到错误立即退出

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 检查是否为root用户
check_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "此脚本需要root权限运行"
        log_info "请使用: sudo $0"
        exit 1
    fi
}

# 检查系统版本
check_centos() {
    if [[ -f /etc/redhat-release ]]; then
        local version=$(cat /etc/redhat-release)
        log_info "检测到系统: $version"
    else
        log_warning "未检测到CentOS/RHEL系统，继续执行..."
    fi
}

# 检查并配置DNS
check_and_config_dns() {
    log_info "检查DNS配置..."
    
    # 测试DNS解析
    if ! nslookup mirrors.aliyun.com > /dev/null 2>&1 && ! ping -c 1 -W 2 mirrors.aliyun.com > /dev/null 2>&1; then
        log_warning "DNS解析失败，尝试配置DNS服务器..."
        
        # 检查resolv.conf
        if ! grep -q "nameserver 8.8.8.8" /etc/resolv.conf 2>/dev/null; then
            log_info "配置DNS服务器..."
            # 备份原配置
            cp /etc/resolv.conf /etc/resolv.conf.bak.$(date +%Y%m%d_%H%M%S) 2>/dev/null || true
            
            # 添加DNS服务器
            {
                echo "# Generated by deploy script"
                echo "nameserver 8.8.8.8"
                echo "nameserver 114.114.114.114"
                echo "nameserver 223.5.5.5"
                if [[ -f /etc/resolv.conf ]]; then
                    grep -v "^nameserver" /etc/resolv.conf | grep -v "^# Generated" || true
                fi
            } > /tmp/resolv.conf.new
            
            mv /tmp/resolv.conf.new /etc/resolv.conf
            log_success "DNS配置已更新"
        fi
        
        # 再次测试
        sleep 2
        if ! nslookup mirrors.aliyun.com > /dev/null 2>&1 && ! ping -c 1 -W 2 mirrors.aliyun.com > /dev/null 2>&1; then
            log_error "DNS仍然无法解析，请检查网络连接"
            read -p "是否继续部署? (y/n): " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                exit 1
            fi
        else
            log_success "DNS解析正常"
        fi
    else
        log_success "DNS解析正常"
    fi
}

# 检查并安装Python 3
install_python3() {
    log_info "检查Python 3..."
    
    if command -v python3 &> /dev/null; then
        local version=$(python3 --version 2>&1)
        log_success "Python 3已安装: $version"
        
        # 检查版本是否 >= 3.7
        local major=$(python3 -c "import sys; print(sys.version_info.major)" 2>/dev/null)
        local minor=$(python3 -c "import sys; print(sys.version_info.minor)" 2>/dev/null)
        
        if [[ "$major" -lt 3 ]] || [[ "$major" -eq 3 && "$minor" -lt 7 ]]; then
            log_warning "Python版本过低 ($major.$minor)，需要 >= 3.7"
            log_info "尝试安装Python 3.7+..."
            install_python3_from_source
        fi
    else
        log_info "Python 3未安装，开始安装..."
        install_python3_from_source
    fi
    
    # 检查pip（确保使用正确的版本）
    log_info "检查 pip..."
    
    # 如果安装了 Python 3.8，优先使用 pip3.8
    if command -v python3.8 &> /dev/null; then
        if ! command -v pip3.8 &> /dev/null; then
            log_info "为 Python 3.8 安装 pip..."
            python3.8 -m ensurepip --upgrade || {
                curl -sSL https://bootstrap.pypa.io/get-pip.py | python3.8
            }
        fi
        # 创建 pip3 软链接指向 pip3.8
        if command -v pip3.8 &> /dev/null; then
            local pip38_path=$(which pip3.8)
            local current_pip3_link=$(readlink /usr/bin/pip3 2>/dev/null || echo "")
            if [[ ! -f /usr/bin/pip3 ]] || [[ "$current_pip3_link" != *"pip3.8"* ]]; then
                ln -sf "$pip38_path" /usr/bin/pip3 2>/dev/null || true
            fi
        fi
    elif ! command -v pip3 &> /dev/null; then
        log_info "安装pip..."
        yum install -y python3-pip || {
            log_warning "yum安装pip失败，尝试使用get-pip.py..."
            curl -sSL https://bootstrap.pypa.io/get-pip.py | python3
        }
    fi
    
    # 验证 Python 和 pip 版本
    local final_python_version=$(python3 --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
    log_success "Python 3环境就绪: Python $final_python_version"
    
    if command -v pip3 &> /dev/null; then
        local pip_version=$(pip3 --version 2>&1 | head -1)
        log_info "pip 版本: $pip_version"
    fi
}

# 从源码安装Python 3（如果需要）
install_python3_from_source() {
    log_info "尝试安装 Python 3.7+..."
    
    # 方法1: 尝试使用 IUS 仓库安装 Python 3.8（推荐，最简单）
    log_info "方法1: 尝试使用 IUS 仓库安装 Python 3.8..."
    
    # 安装 IUS 仓库（尝试多个镜像源）
    if ! rpm -qa | grep -q ius-release; then
        log_info "安装 IUS 仓库（尝试多个镜像源）..."
        
        local ius_repo_installed=false
        local ius_repo_urls=(
            "https://repo.ius.io/ius-release-el7.rpm"
            "https://mirrors.tuna.tsinghua.edu.cn/ius/ius-release-el7.rpm"
            "https://mirrors.aliyun.com/ius/ius-release-el7.rpm"
        )
        
        for repo_url in "${ius_repo_urls[@]}"; do
            log_info "尝试从 $repo_url 安装 IUS 仓库..."
            if yum install -y "$repo_url" 2>&1 | grep -q "Complete\|Installed"; then
                ius_repo_installed=true
                log_success "IUS 仓库安装成功"
                break
            fi
        done
        
        if [[ "$ius_repo_installed" == "false" ]]; then
            log_warning "所有 IUS 仓库镜像源都失败，尝试其他方法..."
        fi
    fi
    
    # 尝试安装 Python 3.8
    log_info "安装 Python 3.8 及相关包..."
    if yum install -y python38u python38u-pip python38u-devel > /tmp/python_install.log 2>&1; then
        log_success "Python 3.8 安装成功（来自 IUS 仓库）"
        
        # 等待一下让系统更新
        sleep 2
        
        # 查找 python3.8 的实际位置
        local python38_path=$(which python3.8 2>/dev/null || find /usr -name python3.8 2>/dev/null | head -1)
        
        if [[ -z "$python38_path" ]]; then
            # 尝试常见路径
            if [[ -f /usr/bin/python3.8 ]]; then
                python38_path="/usr/bin/python3.8"
            elif [[ -f /usr/local/bin/python3.8 ]]; then
                python38_path="/usr/local/bin/python3.8"
            fi
        fi
        
        if [[ -n "$python38_path" ]]; then
            # 创建 python3.8 的软链接（如果不存在）
            if [[ ! -f /usr/bin/python3.8 ]]; then
                ln -sf "$python38_path" /usr/bin/python3.8 2>/dev/null || true
            fi
            
            # 更新 python3 命令指向 python3.8
            # 备份原有的 python3（如果存在且不是 3.8）
            if command -v python3 &> /dev/null; then
                local current_py3=$(python3 --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
                if [[ "$current_py3" != "3.8" ]]; then
                    mv /usr/bin/python3 /usr/bin/python3.old 2>/dev/null || true
                fi
            fi
            ln -sf "$python38_path" /usr/bin/python3 2>/dev/null || true
            
            # 验证安装
            if python3.8 --version 2>&1 | grep -q "3.8"; then
                log_success "已更新 python3 命令指向 Python 3.8"
                log_info "Python 版本: $(python3.8 --version 2>&1)"
                return 0
            else
                log_warning "Python 3.8 安装可能不完整，继续尝试其他方法..."
            fi
        else
            log_warning "无法找到 python3.8 可执行文件，继续尝试其他方法..."
        fi
    else
        log_warning "IUS 仓库安装 Python 3.8 失败"
        log_info "安装日志: /tmp/python_install.log"
    fi
    
    # 方法2: 尝试使用 SCL (Software Collections)
    log_info "方法2: 尝试使用 SCL 安装 Python 3.8..."
    
    # 安装 SCL
    if ! rpm -qa | grep -q scl-utils; then
        yum install -y scl-utils || true
    fi
    
    # 尝试安装 rh-python38
    if yum install -y rh-python38 rh-python38-python-devel 2>&1; then
        log_success "Python 3.8 安装成功（来自 SCL）"
        log_info "注意: 使用 SCL 时，需要运行 'scl enable rh-python38 bash' 来激活"
        log_info "或者使用完整路径: /opt/rh/rh-python38/root/usr/bin/python3"
        
        # 创建便捷的 python3 命令
        cat > /usr/local/bin/python3 << 'EOF'
#!/bin/bash
/opt/rh/rh-python38/root/usr/bin/python3 "$@"
EOF
        chmod +x /usr/local/bin/python3
        
        # 安装 pip
        /opt/rh/rh-python38/root/usr/bin/python3 -m ensurepip --upgrade || {
            curl -sSL https://bootstrap.pypa.io/get-pip.py | /opt/rh/rh-python38/root/usr/bin/python3
        }
        
        return 0
    else
        log_warning "SCL 安装 Python 3.8 失败"
    fi
    
    # 方法3: 从源码编译 Python 3.8（最后手段，较慢）
    log_info "方法3: 从源码编译 Python 3.8（自动执行，这可能需要 10-30 分钟）..."
    log_warning "注意: 从源码编译需要较长时间，请耐心等待..."
    
    # 检查是否有之前失败的安装，需要清理
    local python_dir="/usr/local/python38"
    if [[ -d "$python_dir" ]] && [[ ! -f "$python_dir/bin/python3.8" ]] || \
       ([[ -f "$python_dir/bin/python3.8" ]] && ! "$python_dir/bin/python3.8" --version 2>&1 | grep -q "3.8"); then
        log_warning "检测到之前不完整的安装，清理中..."
        rm -rf "$python_dir" 2>/dev/null || true
    fi
    
    # 检查并安装编译工具
    if ! command -v gcc &> /dev/null || ! command -v make &> /dev/null; then
        log_info "安装编译工具..."
        yum groupinstall -y "Development Tools" 2>&1 | grep -v "already installed" || {
            yum install -y gcc gcc-c++ make
        }
    fi
    
    log_info "安装 Python 编译所需的开发库..."
    yum install -y openssl-devel bzip2-devel libffi-devel zlib-devel readline-devel sqlite-devel xz-devel 2>&1 | grep -v "already installed" || true
    
    # 下载并编译 Python 3.8
    local python_version="3.8.18"
    local python_dir="/usr/local/python38"
    
    log_info "下载 Python ${python_version} 源码（尝试多个镜像源）..."
    cd /tmp
    
    local download_success=false
    local download_urls=(
        "https://www.python.org/ftp/python/${python_version}/Python-${python_version}.tgz"
        "https://mirrors.huaweicloud.com/python/${python_version}/Python-${python_version}.tgz"
        "https://mirrors.aliyun.com/python-release/${python_version}/Python-${python_version}.tgz"
        "https://npm.taobao.org/mirrors/python/${python_version}/Python-${python_version}.tgz"
    )
    
    for url in "${download_urls[@]}"; do
        log_info "尝试从 $url 下载..."
        if wget --timeout=30 --tries=3 "$url" -O Python-${python_version}.tgz 2>&1; then
            if [[ -f "Python-${python_version}.tgz" ]] && [[ -s "Python-${python_version}.tgz" ]]; then
                download_success=true
                log_success "下载成功"
                break
            else
                rm -f Python-${python_version}.tgz 2>/dev/null || true
            fi
        fi
    done
    
    if [[ "$download_success" == "false" ]]; then
        log_error "所有下载源都失败，无法下载 Python 源码"
        log_info ""
        log_info "请手动下载并安装 Python 3.8:"
        log_info "1. 下载: wget https://www.python.org/ftp/python/3.8.18/Python-3.8.18.tgz"
        log_info "2. 解压: tar xzf Python-3.8.18.tgz"
        log_info "3. 编译安装: cd Python-3.8.18 && ./configure --prefix=/usr/local/python38 --enable-optimizations && make && make altinstall"
        exit 1
    fi
    
    log_info "解压源码包..."
    tar xzf Python-${python_version}.tgz || {
        log_error "解压失败"
        exit 1
    }
    
    cd Python-${python_version} || {
        log_error "无法进入源码目录"
        exit 1
    }
    
    log_info "配置编译选项（这可能需要几分钟）..."
    # 不使用 --enable-optimizations 可以加快编译速度，避免某些问题
    ./configure --prefix=${python_dir} --with-ensurepip=install 2>&1 | tee /tmp/python_configure.log || {
        log_error "配置失败，查看日志: /tmp/python_configure.log"
        exit 1
    }
    
    log_info "开始编译（这可能需要 10-30 分钟，请耐心等待）..."
    log_info "使用 $(nproc) 个并行任务加速编译..."
    
    # 先清理之前的编译结果
    make clean 2>/dev/null || true
    
    # 使用 timeout 防止无限等待，最多 1 小时
    if timeout 3600 make -j$(nproc) 2>&1 | tee /tmp/python_make.log; then
        log_success "编译成功"
    else
        local make_exit_code=$?
        if [[ $make_exit_code -eq 124 ]]; then
            log_error "编译超时（超过1小时）"
            exit 1
        else
            log_warning "并行编译失败，尝试单线程编译..."
            if make 2>&1 | tee -a /tmp/python_make.log; then
                log_success "单线程编译成功"
            else
                log_error "编译失败，查看日志: /tmp/python_make.log"
                exit 1
            fi
        fi
    fi
    
    log_info "安装 Python（这可能需要几分钟）..."
    # 先尝试 make install（完整安装），如果失败再尝试 altinstall
    if make install 2>&1 | tee /tmp/python_install.log; then
        log_success "Python 安装成功（完整安装）"
    else
        log_warning "完整安装失败，尝试 altinstall..."
        # 清理部分安装的文件
        rm -rf ${python_dir}/bin/python3.8 ${python_dir}/lib/python3.8 2>/dev/null || true
        
        # 重新编译（可能需要）
        make clean 2>/dev/null || true
        make -j$(nproc) 2>&1 | tee /tmp/python_make2.log || make 2>&1 | tee /tmp/python_make2.log || {
            log_error "重新编译失败"
            exit 1
        }
        
        # 尝试 altinstall
        if make altinstall 2>&1 | tee -a /tmp/python_install.log; then
            log_success "Python 安装成功（altinstall）"
        else
            log_error "安装失败，查看日志: /tmp/python_install.log"
            log_info "尝试手动修复..."
            
            # 检查是否至少 python3.8 可执行文件存在
            if [[ -f ${python_dir}/bin/python3.8 ]]; then
                log_info "Python 可执行文件存在，尝试修复库路径..."
                # 设置 PYTHONHOME 环境变量
                export PYTHONHOME=${python_dir}
                
                # 尝试运行 python3.8 看看是否能工作
                if ${python_dir}/bin/python3.8 --version 2>&1 | grep -q "3.8"; then
                    log_success "Python 3.8 可以运行"
                else
                    log_error "Python 3.8 无法正常运行，可能需要重新编译"
                    exit 1
                fi
            else
                log_error "Python 可执行文件不存在，安装完全失败"
                exit 1
            fi
        fi
    fi
    
    # 创建软链接
    log_info "创建 Python 3.8 软链接..."
    if [[ -f ${python_dir}/bin/python3.8 ]]; then
        # 设置环境变量
        export PYTHONHOME=${python_dir}
        export PATH=${python_dir}/bin:$PATH
        
        # 创建软链接
        ln -sf ${python_dir}/bin/python3.8 /usr/bin/python3.8 2>/dev/null || true
        ln -sf ${python_dir}/bin/python3.8 /usr/bin/python3 2>/dev/null || true
        
        # 验证 Python 是否可以运行
        log_info "验证 Python 安装..."
        if ${python_dir}/bin/python3.8 --version 2>&1 | grep -q "3.8"; then
            local py_version=$(${python_dir}/bin/python3.8 --version 2>&1)
            log_success "Python 可以运行: $py_version"
        else
            log_error "Python 无法正常运行"
            log_info "检查 Python 库文件..."
            if [[ ! -d ${python_dir}/lib/python3.8 ]]; then
                log_error "Python 库目录不存在，安装不完整"
                log_info "尝试重新安装..."
                make install 2>&1 | tee /tmp/python_reinstall.log || {
                    log_error "重新安装失败"
                    exit 1
                }
            fi
        fi
        
        # 安装 pip（如果还没有）
        log_info "安装 pip..."
        if [[ -f ${python_dir}/bin/pip3.8 ]] || [[ -f ${python_dir}/bin/pip3 ]]; then
            log_success "pip 已存在"
            if [[ -f ${python_dir}/bin/pip3.8 ]]; then
                ln -sf ${python_dir}/bin/pip3.8 /usr/bin/pip3 2>/dev/null || true
            elif [[ -f ${python_dir}/bin/pip3 ]]; then
                ln -sf ${python_dir}/bin/pip3 /usr/bin/pip3 2>/dev/null || true
            fi
        else
            log_info "使用 ensurepip 安装 pip..."
            PYTHONHOME=${python_dir} ${python_dir}/bin/python3.8 -m ensurepip --upgrade 2>&1 || {
                log_warning "ensurepip 失败，尝试使用 get-pip.py..."
                curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || {
                    log_error "下载 get-pip.py 失败"
                    exit 1
                }
                PYTHONHOME=${python_dir} ${python_dir}/bin/python3.8 /tmp/get-pip.py 2>&1 || {
                    log_error "安装 pip 失败"
                    exit 1
                }
            }
            
            # 创建 pip 软链接
            if [[ -f ${python_dir}/bin/pip3.8 ]]; then
                ln -sf ${python_dir}/bin/pip3.8 /usr/bin/pip3 2>/dev/null || true
            elif [[ -f ${python_dir}/bin/pip3 ]]; then
                ln -sf ${python_dir}/bin/pip3 /usr/bin/pip3 2>/dev/null || true
            fi
        fi
        
        # 最终验证
        log_info "最终验证 Python 和 pip..."
        if python3.8 --version 2>&1 | grep -q "3.8"; then
            log_success "Python 3.8 编译安装完成"
            log_info "Python 版本: $(python3.8 --version 2>&1)"
            
            if command -v pip3 &> /dev/null; then
                log_info "pip 版本: $(pip3 --version 2>&1 | head -1)"
            else
                log_warning "pip 未正确安装，但 Python 可以使用"
            fi
        else
            log_error "Python 3.8 安装验证失败"
            log_info "Python 路径: ${python_dir}/bin/python3.8"
            log_info "请检查日志文件: /tmp/python_*.log"
            exit 1
        fi
    else
        log_error "Python 3.8 可执行文件不存在: ${python_dir}/bin/python3.8"
        exit 1
    fi
    
    # 清理（可选，保留源码以便调试）
    log_info "清理临时文件..."
    cd / 2>/dev/null || true
    # 保留源码一段时间以便调试，可以手动删除
    # rm -rf /tmp/Python-${python_version}*
}

# 检查并安装PostgreSQL
install_postgresql() {
    log_info "检查PostgreSQL..."
    
    if command -v psql &> /dev/null; then
        local version=$(psql --version 2>&1 | head -1)
        log_success "PostgreSQL已安装: $version"
        
        # 检查PostgreSQL服务是否运行
        if systemctl is-active --quiet postgresql || systemctl is-active --quiet postgresql-server; then
            log_success "PostgreSQL服务正在运行"
        else
            log_warning "PostgreSQL服务未运行，尝试启动..."
            start_postgresql_service
        fi
    else
        log_info "PostgreSQL未安装，开始安装..."
        
        # 安装PostgreSQL仓库
        if [[ ! -f /etc/yum.repos.d/pgdg-redhat-all.repo ]]; then
            log_info "添加PostgreSQL官方仓库..."
            yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm 2>&1 | grep -v "already installed" || {
                log_warning "官方仓库添加失败，使用系统仓库..."
            }
        fi
        
        # 安装PostgreSQL 15（如果可用）或系统默认版本
        if yum list available postgresql15-server &> /dev/null; then
            log_info "安装PostgreSQL 15..."
            yum install -y postgresql15-server postgresql15
            POSTGRES_VERSION="15"
        elif yum list available postgresql12-server &> /dev/null; then
            log_info "安装PostgreSQL 12..."
            yum install -y postgresql12-server postgresql12
            POSTGRES_VERSION="12"
        else
            log_info "安装系统默认PostgreSQL版本..."
            yum install -y postgresql-server postgresql
            POSTGRES_VERSION=""
        fi
        
        # 初始化数据库
        log_info "初始化PostgreSQL数据库..."
        if [[ -n "$POSTGRES_VERSION" ]]; then
            /usr/pgsql-${POSTGRES_VERSION}/bin/postgresql-${POSTGRES_VERSION}-setup initdb || {
                log_warning "初始化失败，可能已经初始化过"
            }
        else
            postgresql-setup initdb || {
                log_warning "初始化失败，可能已经初始化过"
            }
        fi
        
        # 启动服务
        start_postgresql_service
        
        log_success "PostgreSQL安装完成"
    fi
}

# 启动PostgreSQL服务
start_postgresql_service() {
    local service_name=""
    
    # 检测服务名称
    if systemctl list-unit-files | grep -q "postgresql-15"; then
        service_name="postgresql-15"
    elif systemctl list-unit-files | grep -q "postgresql-12"; then
        service_name="postgresql-12"
    elif systemctl list-unit-files | grep -q "postgresql-server"; then
        service_name="postgresql-server"
    else
        service_name="postgresql"
    fi
    
    log_info "启动PostgreSQL服务: $service_name"
    systemctl enable $service_name
    systemctl start $service_name
    
    # 等待服务启动
    local retries=0
    while [[ $retries -lt 10 ]]; do
        if systemctl is-active --quiet $service_name; then
            log_success "PostgreSQL服务已启动"
            sleep 2  # 等待服务完全就绪
            return 0
        fi
        retries=$((retries + 1))
        sleep 1
    done
    
    log_error "PostgreSQL服务启动失败"
    exit 1
}

# 配置PostgreSQL数据库
configure_postgresql() {
    log_info "配置PostgreSQL数据库..."
    
    # 检测PostgreSQL版本和路径
    local psql_path=""
    local pg_version=""
    
    if command -v psql &> /dev/null; then
        psql_path=$(which psql)
        pg_version=$(psql --version | grep -oE '[0-9]+\.[0-9]+' | head -1 | cut -d. -f1)
    fi
    
    # 检测数据目录
    local pg_data_dir=""
    if [[ -d /var/lib/pgsql/${pg_version}/data ]]; then
        pg_data_dir="/var/lib/pgsql/${pg_version}/data"
    elif [[ -d /var/lib/pgsql/data ]]; then
        pg_data_dir="/var/lib/pgsql/data"
    else
        log_warning "无法找到PostgreSQL数据目录，使用默认配置"
    fi
    
    # 配置PostgreSQL允许本地连接（如果需要）
    if [[ -n "$pg_data_dir" ]] && [[ -f "${pg_data_dir}/pg_hba.conf" ]]; then
        log_info "配置PostgreSQL认证方式..."
        # 确保本地连接使用md5或trust
        if ! grep -q "^local.*all.*all.*md5\|^local.*all.*all.*trust" "${pg_data_dir}/pg_hba.conf"; then
            # 备份配置文件
            cp "${pg_data_dir}/pg_hba.conf" "${pg_data_dir}/pg_hba.conf.bak.$(date +%Y%m%d_%H%M%S)"
            
            # 添加本地连接配置（如果不存在）
            if ! grep -q "^local.*all.*all" "${pg_data_dir}/pg_hba.conf"; then
                sed -i '/^# "local" is for Unix domain socket connections only/a local   all             all                                     md5' "${pg_data_dir}/pg_hba.conf"
            fi
        fi
        
        # 重启服务使配置生效
        if systemctl is-active --quiet postgresql-${pg_version} || systemctl is-active --quiet postgresql-server; then
            log_info "重启PostgreSQL服务使配置生效..."
            systemctl restart postgresql-${pg_version} 2>/dev/null || systemctl restart postgresql-server 2>/dev/null || true
            sleep 2
        fi
    fi
    
    # 创建数据库和用户
    log_info "创建数据库和用户..."
    
    # 检查用户是否存在
    if sudo -u postgres psql -tAc "SELECT 1 FROM pg_roles WHERE rolname='app';" 2>/dev/null | grep -q 1; then
        log_info "数据库用户 'app' 已存在"
    else
        log_info "创建数据库用户: app"
        sudo -u postgres psql -c "CREATE USER app WITH PASSWORD 'app';" 2>/dev/null || {
            log_warning "创建用户失败，可能已存在或权限不足"
        }
    fi
    
    # 检查数据库是否存在
    if sudo -u postgres psql -tAc "SELECT 1 FROM pg_database WHERE datname='pvp';" 2>/dev/null | grep -q 1; then
        log_info "数据库 'pvp' 已存在"
    else
        log_info "创建数据库: pvp"
        sudo -u postgres psql -c "CREATE DATABASE pvp OWNER app;" 2>/dev/null || {
            log_warning "创建数据库失败，可能已存在或权限不足"
        }
    fi
    
    # 授予权限
    log_info "授予数据库权限..."
    sudo -u postgres psql -d pvp -c "GRANT ALL PRIVILEGES ON DATABASE pvp TO app;" 2>/dev/null || true
    sudo -u postgres psql -d pvp -c "GRANT ALL ON SCHEMA public TO app;" 2>/dev/null || true
    
    log_success "PostgreSQL配置完成"
}

# 创建Python虚拟环境
setup_python_venv() {
    log_info "设置Python虚拟环境..."
    
    local project_dir=$(pwd)
    
    # 首先检查系统 Python 版本，确保 >= 3.7
    log_info "检查系统 Python 版本..."
    if ! command -v python3 &> /dev/null; then
        log_error "未找到 python3 命令"
        exit 1
    fi
    
    local sys_python_version=$(python3 --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
    local sys_python_major=$(echo "$sys_python_version" | cut -d. -f1)
    local sys_python_minor=$(echo "$sys_python_version" | cut -d. -f2)
    
    if [[ "$sys_python_major" -lt 3 ]] || [[ "$sys_python_major" -eq 3 && "$sys_python_minor" -lt 7 ]]; then
        log_error "系统 Python 版本过低: $sys_python_version，fastapi 0.103.2 需要 Python 3.7+"
        log_info "请先升级 Python 版本"
        exit 1
    else
        log_success "系统 Python 版本符合要求: $sys_python_version"
    fi
    
    # 检查虚拟环境是否存在且版本正确
    local need_recreate=false
    
    if [[ -d "${project_dir}/.venv" ]] && [[ -f "${project_dir}/.venv/bin/activate" ]]; then
        log_info "虚拟环境已存在，检查 Python 版本..."
        
        # 直接检查虚拟环境中的 Python 可执行文件版本
        if [[ -f "${project_dir}/.venv/bin/python" ]]; then
            local venv_python_version=$("${project_dir}/.venv/bin/python" --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
            local venv_python_major=$(echo "$venv_python_version" | cut -d. -f1)
            local venv_python_minor=$(echo "$venv_python_version" | cut -d. -f2)
            
            log_info "虚拟环境 Python 版本: $venv_python_version"
            
            if [[ "$venv_python_major" -lt 3 ]] || [[ "$venv_python_major" -eq 3 && "$venv_python_minor" -lt 7 ]]; then
                log_warning "虚拟环境 Python 版本过低 ($venv_python_version)，需要 >= 3.7"
                log_info "将删除旧虚拟环境并重新创建..."
                need_recreate=true
            else
                log_success "虚拟环境 Python 版本符合要求: $venv_python_version"
            fi
        else
            log_warning "虚拟环境中找不到 Python 可执行文件，将重新创建..."
            need_recreate=true
        fi
    else
        log_info "虚拟环境不存在，将创建新的虚拟环境"
        need_recreate=true
    fi
    
    # 如果需要重新创建，删除旧环境
    if [[ "$need_recreate" == "true" ]]; then
        if [[ -d "${project_dir}/.venv" ]]; then
            log_info "删除旧的虚拟环境..."
            rm -rf "${project_dir}/.venv"
        fi
        
        log_info "使用 Python $sys_python_version 创建虚拟环境..."
        python3 -m venv .venv || {
            log_error "虚拟环境创建失败"
            exit 1
        }
        
        # 再次验证虚拟环境是否创建成功
        if [[ ! -f "${project_dir}/.venv/bin/activate" ]]; then
            log_error "虚拟环境创建失败：activate 文件不存在"
            exit 1
        fi
    else
        log_info "虚拟环境已存在且版本正确，跳过创建"
    fi
    
    log_info "激活虚拟环境并安装依赖..."
    
    # 检查 activate 文件是否存在
    if [[ ! -f ".venv/bin/activate" ]]; then
        log_error "虚拟环境激活文件不存在: .venv/bin/activate"
        log_info "尝试重新创建虚拟环境..."
        rm -rf .venv
        python3 -m venv .venv || {
            log_error "重新创建虚拟环境失败"
            exit 1
        }
    fi
    
    source .venv/bin/activate || {
        log_error "激活虚拟环境失败"
        exit 1
    }
    
    # 再次确认虚拟环境中的 Python 版本
    log_info "验证虚拟环境 Python 版本..."
    local python_version=$(python --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
    local python_major=$(echo "$python_version" | cut -d. -f1)
    local python_minor=$(echo "$python_version" | cut -d. -f2)
    
    if [[ "$python_major" -lt 3 ]] || [[ "$python_major" -eq 3 && "$python_minor" -lt 7 ]]; then
        log_error "虚拟环境 Python 版本过低: $python_version，fastapi 0.103.2 需要 Python 3.7+"
        log_info "尝试删除并重新创建虚拟环境..."
        deactivate 2>/dev/null || true
        rm -rf .venv
        python3 -m venv .venv || {
            log_error "重新创建虚拟环境失败"
            exit 1
        }
        source .venv/bin/activate || {
            log_error "激活虚拟环境失败"
            exit 1
        }
        python_version=$(python --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
        log_success "重新创建后的 Python 版本: $python_version"
    else
        log_success "Python 版本符合要求: $python_version"
    fi
    
    # 升级pip（优先使用官方源，因为镜像源可能同步延迟）
    log_info "升级 pip..."
    if pip install --upgrade pip --index-url https://pypi.org/simple --timeout 60 2>&1; then
        log_success "pip 升级成功（使用官方源）"
    elif pip install --upgrade pip -i https://pypi.tuna.tsinghua.edu.cn/simple --timeout 60 2>&1; then
        log_success "pip 升级成功（使用清华镜像源）"
    else
        log_warning "pip 升级失败，继续尝试安装依赖..."
    fi
    
    # 安装依赖（优先使用官方源，因为新版本包可能在镜像源中不可用）
    if [[ -f requirements.txt ]]; then
        log_info "安装Python依赖包..."
        
        # 检查 pip 配置文件，可能已配置镜像源
        local pip_config_file=""
        local pip_config_backup=""
        
        # 检查用户级配置
        if [[ -f ~/.pip/pip.conf ]]; then
            pip_config_file="$HOME/.pip/pip.conf"
        elif [[ -f ~/.config/pip/pip.conf ]]; then
            pip_config_file="$HOME/.config/pip/pip.conf"
        fi
        
        # 检查系统级配置
        if [[ -z "$pip_config_file" ]] && [[ -f /etc/pip.conf ]]; then
            pip_config_file="/etc/pip.conf"
        fi
        
        # 如果存在配置文件且包含镜像源，临时备份并修改
        if [[ -n "$pip_config_file" ]] && grep -q "index-url\|extra-index-url" "$pip_config_file" 2>/dev/null; then
            log_warning "检测到 pip 配置文件已设置镜像源: $pip_config_file"
            log_info "临时备份配置文件以使用官方源..."
            pip_config_backup="${pip_config_file}.bak.$(date +%Y%m%d_%H%M%S)"
            cp "$pip_config_file" "$pip_config_backup"
            
            # 临时注释掉镜像源配置
            sed -i.tmp 's/^\(.*index-url.*\)/# \1/' "$pip_config_file" 2>/dev/null || true
            sed -i.tmp 's/^\(.*extra-index-url.*\)/# \1/' "$pip_config_file" 2>/dev/null || true
            rm -f "${pip_config_file}.tmp" 2>/dev/null || true
        fi
        
        # 定义多个镜像源（按优先级排序）
        # 优先使用官方源，因为新版本包可能在镜像源中不可用
        local install_success=false
        local source_name=""
        
        # 1. 首先尝试官方 PyPI 源（明确指定，覆盖配置文件）
        log_info "尝试使用官方 PyPI 源（推荐，版本最新）..."
        log_info "使用 --index-url 明确指定官方源: https://pypi.org/simple"
        
        if pip install -r requirements.txt --index-url https://pypi.org/simple --timeout 300 2>&1; then
            install_success=true
            source_name="官方 PyPI"
        else
            log_warning "官方源安装失败，尝试其他镜像源..."
            
            # 2. 尝试其他镜像源（使用并行数组）
            local pip_source_urls=(
                "https://mirrors.aliyun.com/pypi/simple"
                "https://pypi.tuna.tsinghua.edu.cn/simple"
            )
            local pip_source_names=(
                "阿里云"
                "清华"
            )
            
            for i in "${!pip_source_urls[@]}"; do
                local source_url="${pip_source_urls[$i]}"
                source_name="${pip_source_names[$i]}"
                
                log_info "尝试使用镜像源: $source_name ($source_url)"
                if pip install -r requirements.txt -i "$source_url" --timeout 120 2>&1; then
                    install_success=true
                    break
                fi
            done
        fi
        
        # 恢复 pip 配置文件（如果备份了）
        if [[ -n "$pip_config_backup" ]] && [[ -f "$pip_config_backup" ]]; then
            log_info "恢复 pip 配置文件..."
            mv "$pip_config_backup" "$pip_config_file"
        fi
        
        if [[ "$install_success" == "true" ]]; then
            log_success "Python依赖安装完成（使用: $source_name）"
        else
            log_error "所有镜像源都失败，无法安装依赖"
            log_info ""
            log_info "建议的解决方案:"
            log_info "1. 检查网络连接"
            log_info "2. 手动安装: pip install -r requirements.txt"
            log_info "3. 如果镜像源版本过旧，必须使用官方源:"
            log_info "   pip install -r requirements.txt --timeout 300"
            exit 1
        fi
    else
        log_error "未找到requirements.txt文件"
        exit 1
    fi
}

# 创建必要的目录
create_directories() {
    log_info "创建必要的目录..."
    mkdir -p data_logs
    log_success "目录创建完成"
}

# 检查端口占用
check_ports() {
    local ports=(8090 5432)
    local conflicts=()
    
    for port in "${ports[@]}"; do
        if netstat -tuln 2>/dev/null | grep -q ":$port "; then
            conflicts+=($port)
        fi
    done
    
    if [[ ${#conflicts[@]} -gt 0 ]]; then
        log_warning "以下端口已被占用: ${conflicts[*]}"
        read -p "是否继续部署? (y/n): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi
}

# 检查必要的文件
check_files() {
    local required_files=("requirements.txt" "backend/app/main.py")
    local missing_files=()
    
    for file in "${required_files[@]}"; do
        if [[ ! -f "$file" ]]; then
            missing_files+=($file)
        fi
    done
    
    if [[ ${#missing_files[@]} -gt 0 ]]; then
        log_error "缺少必要文件: ${missing_files[*]}"
        log_error "请确保在项目根目录运行此脚本"
        exit 1
    fi
    
    log_success "所有必要文件检查通过"
}

# 测试数据库连接
test_database_connection() {
    log_info "测试数据库连接..."
    
    source .venv/bin/activate
    
    python3 << 'PYEOF'
import sys
import os
os.environ.setdefault('POSTGRES_HOST', 'localhost')
os.environ.setdefault('POSTGRES_PORT', '5432')
os.environ.setdefault('POSTGRES_USER', 'app')
os.environ.setdefault('POSTGRES_PASSWORD', 'app')
os.environ.setdefault('POSTGRES_DB', 'pvp')

try:
    from backend.app.database import engine
    with engine.connect() as conn:
        print("✓ 数据库连接成功")
        sys.exit(0)
except Exception as e:
    print(f"✗ 数据库连接失败: {e}")
    sys.exit(1)
PYEOF

    if [[ $? -eq 0 ]]; then
        log_success "数据库连接测试通过"
    else
        log_error "数据库连接测试失败"
        exit 1
    fi
}

# 创建systemd服务文件（可选）
create_systemd_service() {
    log_info "创建systemd服务文件..."
    
    local service_file="/etc/systemd/system/pvp-data.service"
    local project_dir=$(pwd)
    local python_path="${project_dir}/.venv/bin/python"
    local uvicorn_path="${project_dir}/.venv/bin/uvicorn"
    
    cat > "$service_file" << EOF
[Unit]
Description=PVP Data Dashboard API Service
After=network.target postgresql.service

[Service]
Type=simple
User=root
WorkingDirectory=${project_dir}
Environment="PATH=${project_dir}/.venv/bin"
Environment="POSTGRES_HOST=localhost"
Environment="POSTGRES_PORT=5432"
Environment="POSTGRES_USER=app"
Environment="POSTGRES_PASSWORD=app"
Environment="POSTGRES_DB=pvp"
Environment="IMPORT_DIR=${project_dir}/data_logs"
Environment="IMPORT_INTERVAL_SEC=300"
ExecStart=${uvicorn_path} backend.app.main:app --host 0.0.0.0 --port 8090
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

    log_success "systemd服务文件已创建: $service_file"
    log_info "可以使用以下命令管理服务:"
    log_info "  启动服务: systemctl start pvp-data"
    log_info "  停止服务: systemctl stop pvp-data"
    log_info "  查看状态: systemctl status pvp-data"
    log_info "  开机自启: systemctl enable pvp-data"
}

# 显示部署信息
show_deployment_info() {
    echo ""
    log_info "==================== 部署完成 ===================="
    echo ""
    
    local host_ip=$(hostname -I | awk '{print $1}')
    
    log_success "应用访问地址: http://${host_ip}:8090"
    log_success "本地访问地址: http://localhost:8090"
    log_success "健康检查: http://localhost:8090/api/health"
    log_success "数据库健康检查: http://localhost:8090/api/health/db"
    echo ""
    
    log_info "==================== 数据库信息 ===================="
    log_info "主机: localhost"
    log_info "端口: 5432"
    log_info "用户: app"
    log_info "密码: app"
    log_info "数据库: pvp"
    echo ""
    
    log_info "==================== 常用命令 ===================="
    echo "启动服务:"
    echo "  source .venv/bin/activate"
    echo "  uvicorn backend.app.main:app --host 0.0.0.0 --port 8090"
    echo ""
    echo "或使用systemd服务:"
    echo "  systemctl start pvp-data"
    echo ""
    echo "查看日志:"
    echo "  journalctl -u pvp-data -f"
    echo ""
    echo "导入数据:"
    echo "  source .venv/bin/activate"
    echo "  python -m backend.app.ingestion --logs_dir ./data_logs"
    echo ""
    echo "================================================"
}

# 主函数
main() {
    echo ""
    log_info "=========================================="
    log_info "  PVP数据看板系统 - 原生环境部署脚本"
    log_info "=========================================="
    echo ""
    
    # 执行检查
    check_root
    check_centos
    check_files
    check_ports
    create_directories
    
    # 检查并配置DNS
    check_and_config_dns
    
    # 安装依赖
    install_python3
    install_postgresql
    configure_postgresql
    
    # 设置Python环境
    setup_python_venv
    
    # 测试数据库连接
    test_database_connection
    
    # 创建systemd服务（可选）
    read -p "是否创建systemd服务? (y/n): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        create_systemd_service
        systemctl daemon-reload
        log_info "可以使用 'systemctl start pvp-data' 启动服务"
    fi
    
    # 显示部署信息
    show_deployment_info
    
    log_success "部署完成！"
}

# 执行主函数
main "$@"

