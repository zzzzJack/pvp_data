#!/bin/bash

# ============================================
# PVP数据看板系统 - 一键部署脚本 (CentOS)
# ============================================

set -e  # 遇到错误立即退出

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 检查是否为root用户
check_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "此脚本需要root权限运行"
        log_info "请使用: sudo $0"
        exit 1
    fi
}

# 检查系统版本
check_centos() {
    if [[ -f /etc/redhat-release ]]; then
        local version=$(cat /etc/redhat-release)
        log_info "检测到系统: $version"
    else
        log_warning "未检测到CentOS/RHEL系统，继续执行..."
    fi
}

# 检查并配置DNS
check_and_config_dns() {
    log_info "检查DNS配置..."
    
    # 测试DNS解析
    if ! nslookup mirrors.aliyun.com > /dev/null 2>&1 && ! ping -c 1 -W 2 mirrors.aliyun.com > /dev/null 2>&1; then
        log_warning "DNS解析失败，尝试配置DNS服务器..."
        
        # 检查resolv.conf
        if ! grep -q "nameserver 8.8.8.8" /etc/resolv.conf 2>/dev/null; then
            log_info "配置DNS服务器..."
            # 备份原配置
            cp /etc/resolv.conf /etc/resolv.conf.bak.$(date +%Y%m%d_%H%M%S) 2>/dev/null || true
            
            # 添加DNS服务器
            {
                echo "# Generated by deploy script"
                echo "nameserver 8.8.8.8"
                echo "nameserver 114.114.114.114"
                echo "nameserver 223.5.5.5"
                if [[ -f /etc/resolv.conf ]]; then
                    grep -v "^nameserver" /etc/resolv.conf | grep -v "^# Generated" || true
                fi
            } > /tmp/resolv.conf.new
            
            mv /tmp/resolv.conf.new /etc/resolv.conf
            log_success "DNS配置已更新"
        fi
        
        # 配置Docker daemon DNS
        log_info "配置Docker daemon DNS..."
        mkdir -p /etc/docker
        
        # 检查是否需要添加DNS配置
        local need_dns_config=false
        if [[ ! -f /etc/docker/daemon.json ]]; then
            need_dns_config=true
        elif ! grep -q '"dns"' /etc/docker/daemon.json 2>/dev/null; then
            need_dns_config=true
        fi
        
        if [[ "$need_dns_config" == "true" ]]; then
            if command -v python3 &> /dev/null; then
                python3 << 'EOF'
import json
import sys

try:
    with open('/etc/docker/daemon.json', 'r') as f:
        config = json.load(f)
except Exception as e:
    config = {}

# 添加DNS配置
if 'dns' not in config:
    config['dns'] = ['8.8.8.8', '114.114.114.114', '223.5.5.5']
else:
    dns_list = config['dns'] if isinstance(config['dns'], list) else [config['dns']]
    required_dns = ['8.8.8.8', '114.114.114.114', '223.5.5.5']
    for dns in required_dns:
        if dns not in dns_list:
            dns_list.append(dns)
    config['dns'] = dns_list

# 备份原配置
try:
    import shutil
    shutil.copy('/etc/docker/daemon.json', '/etc/docker/daemon.json.bak')
except:
    pass

# 写入新配置
with open('/etc/docker/daemon.json', 'w') as f:
    json.dump(config, f, indent=2, ensure_ascii=False)

print("DNS配置已添加")
EOF
                if [[ $? -eq 0 ]]; then
                    systemctl restart docker 2>/dev/null || true
                    sleep 5  # 等待Docker服务重启完成
                    log_success "Docker daemon DNS配置已更新，服务已重启"
                    
                    # 验证Docker是否正常运行
                    local docker_retries=0
                    while [[ $docker_retries -lt 10 ]]; do
                        if docker info > /dev/null 2>&1; then
                            log_success "Docker服务运行正常"
                            break
                        fi
                        docker_retries=$((docker_retries + 1))
                        sleep 1
                    done
                else
                    log_error "更新Docker daemon配置失败"
                fi
            else
                log_warning "需要python3来更新Docker配置，请手动添加DNS到 /etc/docker/daemon.json"
                log_info "请在 /etc/docker/daemon.json 中添加: \"dns\": [\"8.8.8.8\", \"114.114.114.114\", \"223.5.5.5\"]"
            fi
        else
            log_info "Docker daemon DNS配置已存在，跳过配置"
        fi
        
        # 再次测试
        sleep 2
        if ! nslookup mirrors.aliyun.com > /dev/null 2>&1 && ! ping -c 1 -W 2 mirrors.aliyun.com > /dev/null 2>&1; then
            log_error "DNS仍然无法解析，请检查网络连接或手动配置DNS"
            log_info "请运行以下命令检查网络:"
            echo "  ping -c 3 8.8.8.8"
            echo "  nslookup mirrors.aliyun.com"
            read -p "是否继续部署? (y/n): " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                exit 1
            fi
        else
            log_success "DNS解析正常"
        fi
    else
        log_success "DNS解析正常"
    fi
}

# 安装Docker
install_docker() {
    if command -v docker &> /dev/null; then
        local version=$(docker --version)
        log_success "Docker已安装: $version"
        return 0
    fi

    log_info "开始安装Docker..."
    
    # 卸载旧版本
    yum remove -y docker docker-client docker-client-latest \
        docker-common docker-latest docker-latest-logrotate \
        docker-logrotate docker-engine 2>/dev/null || true

    # 安装必要的工具（先彻底处理可能存在的docker仓库，避免安装时出错）
    log_info "准备安装必要工具..."
    
    # 先彻底处理可能存在的旧Docker仓库
    if [[ -f /etc/yum.repos.d/docker-ce.repo ]]; then
        log_info "发现旧的Docker仓库配置，正在处理..."
        # 尝试禁用仓库（如果yum-utils已安装）
        if command -v yum-config-manager &> /dev/null; then
            yum-config-manager --disable docker-ce-stable 2>/dev/null || true
            yum-config-manager --disable docker-ce-test 2>/dev/null || true
            yum-config-manager --disable docker-ce-nightly 2>/dev/null || true
        fi
        # 备份并删除旧配置（彻底移除，避免yum自动启用）
        local backup_name="docker-ce.repo.bak.$(date +%Y%m%d_%H%M%S)"
        mv /etc/yum.repos.d/docker-ce.repo /etc/yum.repos.d/$backup_name 2>/dev/null || true
        log_info "已备份旧配置到: $backup_name"
    fi
    
    # 清理yum缓存（避免使用旧的仓库信息）
    log_info "清理yum缓存..."
    yum clean all > /dev/null 2>&1 || true
    # 清理metadata缓存
    rm -rf /var/cache/yum/*/docker-ce* 2>/dev/null || true
    
    # 安装必要的工具（使用--disablerepo确保不访问docker仓库）
    log_info "安装必要工具: yum-utils, device-mapper-persistent-data, lvm2"
    if ! yum install -y --disablerepo=docker-ce-stable --disablerepo=docker-ce-test --disablerepo=docker-ce-nightly \
        yum-utils device-mapper-persistent-data lvm2 2>&1 | tee /tmp/yum_install_tools.log; then
        log_warning "使用仓库过滤安装失败，尝试直接安装..."
        # 如果禁用仓库后安装失败，尝试直接安装（可能仓库已经被删除）
        yum install -y yum-utils device-mapper-persistent-data lvm2 || {
            log_error "安装必要工具失败，请检查yum配置"
            exit 1
        }
    fi
    log_success "必要工具安装完成"

    # 添加Docker仓库（优先使用国内镜像源）
    log_info "配置Docker CE仓库..."
    
    # 定义镜像源配置（baseurl, gpgkey）
    local repo_added=false
    
    # 方法1: 尝试从官方下载repo文件，然后修改为国内镜像源
    log_info "尝试下载Docker官方仓库配置文件..."
    if curl -sfL --connect-timeout 10 --max-time 30 "https://download.docker.com/linux/centos/docker-ce.repo" -o /tmp/docker-ce.repo 2>/dev/null; then
        log_success "成功下载官方仓库配置文件"
        repo_added=true
    else
        log_warning "无法从官方源下载，将直接创建仓库配置"
    fi
    
    # 方法2: 测试并选择可用的镜像源（优先国内源）
    # 无论是否下载成功，都测试并选择最佳镜像源
    # 测试国内镜像源可用性（按优先级）
    local mirror_base=""
    local mirror_names=(
        "aliyun:https://mirrors.aliyun.com/docker-ce/linux/centos"
        "tsinghua:https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos"
        "official:https://download.docker.com/linux/centos"
    )
    
    for mirror_info in "${mirror_names[@]}"; do
        local mirror_name=$(echo "$mirror_info" | cut -d: -f1)
        local mirror_url=$(echo "$mirror_info" | cut -d: -f2)
        
        log_info "测试镜像源 [$mirror_name]: $mirror_url"
        
        # 测试镜像源是否可达（多种方式测试）
        local mirror_available=false
        
        # 方法1: 尝试访问repodata（最可靠）
        if curl -sfL --connect-timeout 10 --max-time 30 "${mirror_url}/7/x86_64/stable/repodata/repomd.xml" > /dev/null 2>&1; then
            mirror_available=true
        # 方法2: 尝试访问repo文件（如果方法1失败）
        elif curl -sfL --connect-timeout 10 --max-time 30 "${mirror_url}/docker-ce.repo" > /dev/null 2>&1; then
            mirror_available=true
        # 方法3: 尝试访问基础URL（最后手段）
        elif curl -sfL --connect-timeout 10 --max-time 30 "${mirror_url}/" > /dev/null 2>&1; then
            mirror_available=true
        fi
        
        if [[ "$mirror_available" == "true" ]]; then
            mirror_base="$mirror_url"
            log_success "镜像源 [$mirror_name] 可用，将使用此源"
            break
        else
            log_warning "镜像源 [$mirror_name] 不可用，尝试下一个..."
        fi
    done
    
    if [[ -z "$mirror_base" ]]; then
        log_error "所有镜像源都不可用，请检查网络连接"
        exit 1
    fi
    
    # 如果之前下载了官方文件，且需要使用国内镜像源，则修改baseurl
    if [[ "$repo_added" == "true" ]] && [[ "$mirror_base" != "https://download.docker.com/linux/centos" ]]; then
        log_info "将仓库配置修改为使用国内镜像源..."
        sed -i "s|baseurl=https://download.docker.com|baseurl=$mirror_base|g" /tmp/docker-ce.repo
        sed -i "s|gpgkey=https://download.docker.com|gpgkey=$mirror_base|g" /tmp/docker-ce.repo 2>/dev/null || true
    elif [[ "$repo_added" == "true" ]] && [[ "$mirror_base" == "https://download.docker.com/linux/centos" ]]; then
        log_info "使用官方仓库配置，无需修改"
    else
        # 直接创建仓库配置文件
        log_info "创建Docker仓库配置文件..."
        cat > /tmp/docker-ce.repo << 'EOF'
[docker-ce-stable]
name=Docker CE Stable - $basearch
baseurl=REPLACE_BASEURL/7/$basearch/stable
enabled=1
gpgcheck=1
gpgkey=REPLACE_GPGKEY/linux/centos/gpg
EOF
        sed -i "s|REPLACE_BASEURL|$mirror_base|g" /tmp/docker-ce.repo
        sed -i "s|REPLACE_GPGKEY|$mirror_base|g" /tmp/docker-ce.repo
        repo_added=true
    fi
        
    # 复制到系统目录
    cp /tmp/docker-ce.repo /etc/yum.repos.d/docker-ce.repo
    
    # 验证配置文件内容
    log_info "验证仓库配置文件..."
    if grep -q "baseurl.*$mirror_base" /etc/yum.repos.d/docker-ce.repo 2>/dev/null; then
        log_success "Docker仓库配置已创建，使用镜像源: $mirror_base"
        # 显示配置的关键信息
        log_info "仓库配置内容:"
        grep -E "\[docker-ce|baseurl|gpgkey" /etc/yum.repos.d/docker-ce.repo | head -3 | while read line; do
            log_info "  $line"
        done || true
    else
        log_error "仓库配置文件验证失败"
        exit 1
    fi
    
    # 清理yum缓存并更新（使用新的仓库配置）
    log_info "清理yum缓存并使用新仓库配置..."
    yum clean all > /dev/null 2>&1 || true
    # 清理expire-cache，确保使用新配置
    yum clean expire-cache > /dev/null 2>&1 || true
    
    # 更新仓库缓存（如果失败，会在安装时重试）
    log_info "更新yum仓库缓存..."
    if ! yum makecache fast > /dev/null 2>&1; then
        log_warning "快速缓存更新失败，尝试完整更新..."
        if ! yum makecache > /tmp/yum_makecache.log 2>&1; then
            log_warning "仓库缓存更新失败，但将尝试继续安装..."
            log_info "缓存日志: $(tail -5 /tmp/yum_makecache.log 2>/dev/null || echo '无日志')"
        else
            log_success "仓库缓存更新成功"
        fi
    else
        log_success "仓库缓存更新成功"
    fi

    # 安装Docker（带重试机制）
    log_info "开始安装Docker CE..."
    local install_retries=0
    local max_install_retries=3
    
    while [[ $install_retries -lt $max_install_retries ]]; do
        if yum install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin 2>&1 | tee /tmp/docker_install.log; then
            log_success "Docker安装成功"
            break
        else
            install_retries=$((install_retries + 1))
            if [[ $install_retries -lt $max_install_retries ]]; then
                log_warning "Docker安装失败，第 $install_retries/$max_install_retries 次重试..."
                sleep 5
                # 清理缓存后重试
                yum clean all > /dev/null 2>&1 || true
            else
                log_error "Docker安装失败，已尝试 $max_install_retries 次"
                log_info "安装日志已保存到 /tmp/docker_install.log"
                exit 1
            fi
        fi
    done

    # 启动Docker服务
    systemctl start docker
    systemctl enable docker

    # 验证安装
    if docker --version &> /dev/null; then
        log_success "Docker安装成功: $(docker --version)"
    else
        log_error "Docker安装失败"
        exit 1
    fi
}

# 安装Docker Compose (standalone)
install_docker_compose() {
    if command -v docker-compose &> /dev/null; then
        local version=$(docker-compose --version)
        log_success "Docker Compose已安装: $version"
        return 0
    fi

    log_info "开始安装Docker Compose..."
    
    # 下载Docker Compose
    local compose_version="v2.24.0"
    local compose_url="https://github.com/docker/compose/releases/download/${compose_version}/docker-compose-linux-x86_64"
    
    curl -L "$compose_url" -o /usr/local/bin/docker-compose
    chmod +x /usr/local/bin/docker-compose
    
    # 创建软链接（如果需要）
    if [[ ! -f /usr/bin/docker-compose ]]; then
        ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
    fi

    # 验证安装
    if docker-compose --version &> /dev/null; then
        log_success "Docker Compose安装成功: $(docker-compose --version)"
    else
        log_error "Docker Compose安装失败"
        exit 1
    fi
}

# 检查端口占用
check_ports() {
    local ports=(8090 5432)
    local conflicts=()

    for port in "${ports[@]}"; do
        if netstat -tuln 2>/dev/null | grep -q ":$port "; then
            conflicts+=($port)
        fi
    done

    if [[ ${#conflicts[@]} -gt 0 ]]; then
        log_warning "以下端口已被占用: ${conflicts[*]}"
        read -p "是否继续部署? (y/n): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi
}

# 检查必要的文件
check_files() {
    local required_files=("Dockerfile" "docker-compose.yml" "requirements.txt")
    local missing_files=()

    for file in "${required_files[@]}"; do
        if [[ ! -f "$file" ]]; then
            missing_files+=($file)
        fi
    done

    if [[ ${#missing_files[@]} -gt 0 ]]; then
        log_error "缺少必要文件: ${missing_files[*]}"
        log_error "请确保在项目根目录运行此脚本"
        exit 1
    fi

    log_success "所有必要文件检查通过"
}

# 创建必要的目录
create_directories() {
    log_info "创建必要的目录..."
    mkdir -p data_logs
    log_success "目录创建完成"
}

# 停止旧容器
stop_old_containers() {
    log_info "停止旧容器..."
    docker-compose down 2>/dev/null || true
    log_success "旧容器已停止"
}

# 预拉取基础镜像
pre_pull_images() {
    log_info "预拉取基础镜像..."
    
    # 拉取Python基础镜像
    if ! docker images | grep -q "python.*3.11-slim"; then
        log_info "拉取 python:3.11-slim 镜像..."
        if docker pull python:3.11-slim; then
            log_success "Python基础镜像拉取成功"
        else
            log_warning "Python基础镜像拉取失败，构建时会自动尝试"
        fi
    else
        log_info "Python基础镜像已存在，跳过拉取"
    fi
    
    # 拉取PostgreSQL镜像
    if ! docker images | grep -q "postgres.*15"; then
        log_info "拉取 postgres:15 镜像..."
        if docker pull postgres:15; then
            log_success "PostgreSQL镜像拉取成功"
        else
            log_warning "PostgreSQL镜像拉取失败，构建时会自动尝试"
        fi
    else
        log_info "PostgreSQL镜像已存在，跳过拉取"
    fi
}

# 构建和启动服务
deploy_services() {
    log_info "开始构建和启动服务..."
    
    # 确保Docker服务运行正常
    if systemctl is-active --quiet docker; then
        log_info "检查Docker服务状态..."
        systemctl status docker --no-pager > /dev/null 2>&1 || true
    fi
    
    # 预拉取基础镜像
    pre_pull_images
    
    # 构建镜像
    log_info "构建Docker镜像..."
    log_info "提示: 使用host网络模式构建，可以直接使用宿主机DNS配置"
    
    # 方法1: 使用docker build with --network=host（推荐，直接使用宿主机DNS）
    if docker build --network=host -t pvp_data-app:latest -f Dockerfile .; then
        log_success "Docker镜像构建成功"
    else
        log_warning "使用host网络构建失败，尝试使用docker-compose构建..."
        # 方法2: 使用docker-compose（会使用daemon.json中的DNS配置）
        docker-compose build --no-cache
    fi
    
    # 启动服务
    log_info "启动服务..."
    docker-compose up -d
    
    # 等待服务就绪
    log_info "等待服务启动..."
    sleep 15  # 增加初始等待时间，确保数据库和服务都启动完成
    
    # 检查服务状态
    local max_retries=30
    local retry_count=0
    
    while [[ $retry_count -lt $max_retries ]]; do
        if docker-compose ps | grep -q "Up"; then
            # 先测试健康检查端点（不依赖数据库）
            if curl -sf http://localhost:8090/api/health > /dev/null 2>&1; then
                # 再测试数据库连接端点
                if curl -sf http://localhost:8090/api/health/db > /dev/null 2>&1; then
                    log_success "服务启动成功！应用和数据库连接正常！"
                    return 0
                else
                    log_info "应用已启动，但数据库连接可能还在初始化... ($retry_count/$max_retries)"
                fi
            fi
        fi
        retry_count=$((retry_count + 1))
        sleep 2
        log_info "等待服务就绪... ($retry_count/$max_retries)"
    done
    
    # 如果超时，但仍然显示Up，说明服务可能已经启动但健康检查失败
    if docker-compose ps | grep -q "Up"; then
        log_warning "服务容器已启动，但健康检查未通过"
        log_info "请检查日志: docker-compose logs app"
        log_info "或手动测试: curl http://localhost:8090/api/health"
    else
        log_warning "服务可能未完全启动，请检查日志"
    fi
    return 1
}

# 显示服务状态
show_status() {
    echo ""
    log_info "==================== 服务状态 ===================="
    docker-compose ps
    echo ""
    
    log_info "==================== 服务信息 ===================="
    log_success "应用访问地址: http://$(hostname -I | awk '{print $1}'):8090"
    log_success "本地访问地址: http://localhost:8090"
    log_success "健康检查: http://localhost:8090/api/health"
    log_success "数据库健康检查: http://localhost:8090/api/health/db"
    echo ""
    
    log_info "==================== 常用命令 ===================="
    echo "查看日志: docker-compose logs -f"
    echo "停止服务: docker-compose down"
    echo "重启服务: docker-compose restart"
    echo "查看状态: docker-compose ps"
    echo "================================================"
}

# 主函数
main() {
    echo ""
    log_info "=========================================="
    log_info "  PVP数据看板系统 - 一键部署脚本"
    log_info "=========================================="
    echo ""

    # 执行检查
    check_root
    check_centos
    check_files
    check_ports
    create_directories

    # 检查并配置DNS（需要在安装Docker之前）
    check_and_config_dns

    # 安装依赖
    install_docker
    install_docker_compose

    # 部署服务
    stop_old_containers
    deploy_services

    # 显示状态
    show_status

    log_success "部署完成！"
}

# 执行主函数
main "$@"

